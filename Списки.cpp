/********************************************************************************
 * Л А Б О Р А Т О Р Н А Я   Р А Б О Т А  № 4  З А   3   С Е М Е С Т Р   С  +  +*
 *------------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                    *
 * Project Name  : Lists                                                        *
 * File Name     : Списки. CPP                                                  *
 * Programmer(s) : Викулов Д.Г.  &                                              *
 * Modifyed By   :                                                              *
 * Created       : 14/11/22                                                     *
 * Last Revision : 21/11/22                                                     *
 * Comment(s)    : реализация односвязных списков согласно варианту. Выполнение *
 *                 следующих операций над ними: создание, вывод на экран,       *
 *                 удаление списка. Поиск заданного элемента. Включение нового  *
 *                 элемента в начало списка. Включение нового элемента в конец  *
 *                 списка. Удаление элемента из начала списка. Удаление элемента*
 *                 из конца списка. Удаление элемента с заданной позиции        *
 ********************************************************************************/

#include <iostream>        // стандартные потоки ввода/вывода
#include <iomanip>         // библиотека с модификатором setw
#include <time.h>          // библиотека с модификатором srand
using namespace std;       // используем пространство имён std

/*******************************************************************/
/*            Г Л О Б А Л Ь Н Ы Е   К О Н С Т А Н Т Ы              */
/*******************************************************************/

const int rand_max = 100;  // максимальный случайный элемент, который может попасться в изначальном списке

/*******************************************************************/
/*            Г Л О Б А Л Ь Н Ы Е   П Е Р Е М Е Н Н Ы Е            */
/*******************************************************************/

struct Node                // реализация узла списка  
{ 
	int Data;              // значение, которое в нём хранится  
	Node* next;            // указатель на следующий элемент      
};

/*******************************************************************/
/*              П Р О Т О Т И П Ы    Ф У Н К Ц И Й                 */
/*******************************************************************/

// печать начальных условий для выбора функции
void pechatusloviy();                  // функция не принимает ничего, т. к. просто идёт печать

// печать сформированного массива-вектора в таблице
void pechat_tabl(int* pznachenue       // указатель на первый элемент динамического массива-вектора 
	           , int number);          // количество элементов в массиве-векторе

// создание динамического массива - вектора
void sozdanie(int** pznachenue         // указатель на указатель на динамический массив-вектор, для изменения значения указателя 
	        , int& number);            // количество элементов в массиве-векторе для изменения

// заполнение динамическго массива-вектора
void zapolnenie(int* pznachenue        // указатель на первый элемент динамического массива-вектора 
	          , int number);           // количество элементов в массиве-векторе

// удаление динамического массива - вектора
void udalenie(int* pznachenue);        // указатель на первый элемент динамического массива-вектора

// создание первоначального списка из элементов массива
void List_creation(Node** head         // указатель на указатель на начало списка, т.к изменяется
	             , int* pznachenue     // указатель на первый элемент динамического массива-вектора
	             , int number);        // количество элементов в массиве-векторе

// добавление нового элемента в конец списка
void Adding_to_the_end(Node** head     // указатель на указатель на начало списка, т.к изменяется
	                 , Node** end      // указатель на указатель на конец списка, чтобы при вызове элемент добавлялся всегда в конец
	                 , int uzel);      // значение, которое будем добавлять в список

// вывод списка на экран
void List_output(Node* head);          // указатель на начало списка, чтобы двигаться от него до конца списка

// поиск в списке элемента с заданным значением
void List_search(Node* head);          // указатель на начало списка, чтобы двигаться от него до конца списка

// вывод подкрашенной ячейки в списке после поиска
void List_output_search(Node* head     // указатель на начало списка, чтобы двигаться от него до конца списка
	                   , int uzel);    // значение, которое будем подкрашивать в списке

// удаление списка полностью
void Deleting_a_List(Node** head);     // указатель на указатель на начало списка, т.к изменяется

// добавление нового элемента в начало списка
void Adding_to_the_top(Node** head);   // указатель на указатель на начало списка, т.к изменяется

// удаление элемента из конца списка
void Deletion_at_the_end(Node** head); // указатель на указатель на начало списка, т.к может измениться

// удаление элемента из начала списка
void Deletion_at_the_beginning(Node** head);   // указатель на указатель на начало списка, т.к изменяется

// удаление элемента с заданным номером в списке
void Deletion_by_number(Node** head);  // указатель на указатель на начало списка, т.к может измениться

// промежуточная функция выбора функции из массива
void(*MENU(int& vubor))                // функция, выбранная пользователем
          (Node**);                    // спецификация параметров функции

// работа с выбранной операцией над списком
void pechat_mass_lists(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	                 , Node**head              // указатель на указатель на начало списка, т.к он передаётся далее в другие функции
	                 , int number);            // количество элементов в массиве-векторе

/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/
int main()
{

	system("color F0");                        // делаем консоль светлой
	setlocale(LC_ALL, "Rus");                  // подключаем русский язык
	system("cls");                             // чистим консоль перед выводом
	
	int number = 0;                            // количество элементов массива-вектора
	int* pznachenue = NULL;                    // указатель на динамический массив целых чисел
	Node* head = NULL;                         // указатель на начало списка
	pechat_mass_lists(pznachenue,&head, number);  // вызов основной функции, где будут вызываться другие
	return 0;                                  // возвращаем обещанное значение
}

/*---------------------------------------------------------------------------*/
/* печать условий для выбора функции */
/*-----------------------------------*/
void pechatusloviy()
{
	// Выводим условия в таблице
	setlocale(0, "C");                       // отключаем русский язык
	cout << char(218) << setw(40) << setfill((char)196) << (char)191 << endl << (char)179;  // выводим верхнюю строку шапки
	setlocale(LC_ALL, "Rus");                //подключаем русский язык
	cout << "   Выберите действие со списком:       ";
	setlocale(0, "C");                       // отключаем русский язык
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)194 << setw(35) << setfill((char)196) << (char)180 << setfill(' ') << endl << (char)179;    // выводим нижнюю строку шапки с разделителем между номером и названием алгоритма
	cout << "  1." << (char)179 << "  List_creation                   ";                                                                                                         // выводим условия выбора и нижнюю с боковыми строчками таблицы
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  2." << (char)179 << "  List_output                     ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  3." << (char)179 << "  Deleting_a_List                 ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  4." << (char)179 << "  List_search                     ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  5." << (char)179 << "  Adding_to_the_top               ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  6." << (char)179 << "  Deletion_at_the_end             ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  7." << (char)179 << "  Deletion_at_the_beginning       ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  8." << (char)179 << "  Deletion_by_number              ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << "  9." << (char)179 << "  Repeat with other numbers       ";
	cout << (char)179 << endl << (char)195 << setw(5) << setfill((char)196) << (char)197 << setw(35) << setfill((char)196) << (char)180 << endl << (char)179;
	cout << " 10." << (char)179 << "  Exit.                           ";
	cout << (char)179 << endl << (char)192 << setw(5) << setfill((char)196) << (char)193 << setw(35) << setfill((char)196) << (char)217 << endl;
	setlocale(LC_ALL, "Rus");               // подключаем русский язык
	return;                                 // возвращаем обещанное значение
}// pechatusloviy()

/*--------------------------------------------------------------------------*/
/* печать сформированного массива в таблице */
/*------------------------------------------*/
void pechat_tabl(int* pznachenue  // указатель на первый элемент динамического массива-вектора 
	           , int number)      // количество элементов в массиве-векторе
{
	int j;                        // для прохода по элементам массива
	cout << "\t\t\t\t \x1b[33mЦ Е Л О Ч И С Л Е Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й:\x1b[30m \n";
	setlocale(0, "C");            // выводим массив в красивых скобках
	cout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;          // вывод верхних квадратных скобок
	for (j = 0; j < number; j++)  // идем по всем элементам массива, используя адресную арифметику
	{// выводим элемент массива
		cout << "\n" << char(179) << setw(17) << setfill(' ') << *(pznachenue + j) << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;
	}// for j
	cout << '\n';
	cout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217 << endl;  // вывод нижних квадратных скобок
	setlocale(LC_ALL, "Rus");     // подключаем русский язык
	return;                       // напечатали - вернулись в caller
}//pechat_tabl()


/*---------------------------------------------------------------------------*/
/* создание динамического массива           */
/*------------------------------------------*/
void sozdanie(int** pznachenue    // указатель на указатель на динамический массив-вектор, для изменения значения указателя
	        , int& number)        // количество элементов в массиве-векторе для изменения              
{
	cout << "Введите первоначальное количество элементов списка: ";
	cin >> number;                // размер массива, введённый пользователем
	cout << endl;
	if (!cin.good())              // если количество элементов не число
	{// выход по ошибке
		cout << "Введённое количество элементов не является числом или вне диапазона!!!";
		cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
		system("pause");
		exit(1);                  // закончили программу из функции
	}//if (!cin.good())
	*pznachenue = new int[number];// ввели количество элементов целое число - создали массив на нужное количество элементов
	return;                       // создали - вышли. Вернули обещанное значение в caller
}//sozdanie()


/*-----------------------------------------------------------------------------*/
/*  заполнение динамическго массива - вектора  */
/*---------------------------------------------*/
void zapolnenie(int* pznachenue   // указатель на первый элемент динамического массива-вектора 
	          , int number)       // количество элементов в массиве-векторе          
{
	int i;                        // для цикла заполнения
	srand(time(NULL));            // базовое значение генератора псевдослучайных чисел, чтобы rand выдавал не одно и то же значение при разных вызовах
	for (i = 0; i < number; i++)
	{
		// заполнили массив случайным числом. Могут быть повторы
		pznachenue[i]= rand() % rand_max;
	}// for i
	return;                       // заполнили - вернулись в caller
}// zapolnenie()


/*-----------------------------------------------------------------------------*/
/* удаление динамического массива           */
/*------------------------------------------*/
void udalenie(int* pznachenue)    // указатель на первый элемент динамического массива-вектора
{
	delete[] pznachenue;          // удалили динамический массив-вектор
	return;                       // возвращаем обещанное значение в caller
}// udalenie()


/*-----------------------------------------------------------------------------*/
/* создание первоначального списка из элементов массива */
/*------------------------------------------------------*/
void List_creation(Node** head         // указатель на указатель на начало списка, т.к изменяется
	             , int* pznachenue     // указатель на первый элемент динамического массива-вектора
	             , int number)         // количество элементов в массиве-векторе
{
	// изначально списка нет - его конца не существует
	Node* end;                         // указатель на конец списка
	end = NULL;                        // инициализировали его, чтобы не был диким
	int i;                             // для цикла
	// идём по всем элементам массива и создаём первичный список
	for (i = 0; i < number; i++)
	{
		// вызвали функцию добавления очередного элемента массива в конец списка
		Adding_to_the_end(head, &end, pznachenue[i]);
	}// for i
	List_output(*head);                // выводим список после заполнения на экран
	return;                            // создали - вернулись в caller
}// List_creation()


/*-----------------------------------------------------------------------------*/
/* добавление нового элемента в конец списка */
/*-------------------------------------------*/
void Adding_to_the_end(Node** head     // указатель на указатель на начало списка, т.к изменяется
	                 , Node** end      // указатель на указатель на конец списка, чтобы при вызове элемент добавлялся всегда в конец
	                 , int uzel)       // значение, которое будем добавлять в список
{
	Node* ptr;                         // указатель на очередной узел списка
	ptr = new Node;                    // создали новый узел
	if (*head == NULL)                 // если ещё нет ни одного элемента в списке
	{
		*head = ptr;                   // добавленный элемент будет началом
		(*head)->next = *end;          // следующего элемента - нет
	}
	//иначе-начало в списке уже есть
	else
	{
		(*end)->next = ptr;            // добавляем элемент за концом списка, сформированного ранее
	}// if (*head == NULL)
	ptr->Data = uzel;                  // помещаем туда данные, которые хотели добавить
	*end = ptr;                        // сместили конец списка на добавленный элемент
	(*end)->next = NULL;               // соответсятвенно за новым концом больше нет элементов списка - элемент добавлен
	return;                            // добавили - вернулись в caller
}// Adding_to_the_end()


/*-----------------------------------------------------------------------------*/
/* вывод списка на экран */
/*-----------------------*/
void List_output(Node* head)           // указатель на начало списка, чтобы двигаться от него до конца списка
{
	setlocale(0, "C");                 // отключаем русский язык
	Node* ptr;                         // указатель на очередной узел списка
	ptr = head;                        // начием двигаться от начала списка по порядку
	int n = 1;                         // для вывода нумерации элементов
	// пока не вышли за пределы списка
	while (ptr != NULL)
	{
		if (n != 1)                    // если выводим не первый элемент списка, выводим вернюю строку таблицы без связи для стрелки
		{
			cout << char(218) << setw(7) << setfill((char)196) << (char)194 << setw(5) << setfill((char)196) << char(193) << setw(2) << setfill((char)196) << char(191);
		}
		// иначе - печатаем вернюю строку со связью для стрелки
		else
		{
			cout << char(218) << setw(7) << setfill((char)196) << (char)194 << setw(7) << setfill((char)196)<< char(191);
		}// if (n != 1)
		// выводим левую границу таблицы, данные очередного узла списка и разделитель
		cout << "\n" << char(179) << setw(4) << setfill(' ') << ptr->Data << setw(3) << setfill(' ') << char(179);
		// выводим значение указателя на следующий узел списка, номер узла списка и правую границу таблицы
		cout << setw(5) << setfill(' ') << "NEXT" << setw(2) << char(179) << setw(9) << setfill(' ') << "n = " << n << setw(12) << setfill(' ')<<"NEXT = "<<ptr->next << endl;
		// выводим нижнюю строку таблицы и связь между узлами - стрелку
		cout << char(192) << setw(7) << setfill((char)196) << (char)193 << setw(5) << setfill((char)196) << char(194) << setw(2) << setfill((char)196) << char(217)<<endl;
		n = n + 1;                    // увеличили счётчик элементов
		ptr = ptr->next;              // перешли к следующему узлу списка
	}// while (ptr != NULL)

	// после вывода последнего узла списка выводим то, что указатель далее нулевой -> список закончился
	cout << setw(13) << setfill(' ')<<char(179)<<endl<< setw(16) << setfill(' ') << "NULL\n";
	setlocale(LC_ALL, "Rus");         // подключаем русский язык
	return;                           // вывели - вернулись в caller
}// List_output(Node* head)


/*-----------------------------------------------------------------------------*/
/* удаление списка полностью */
/*---------------------------*/
void Deleting_a_List(Node** head)     // указатель на указатель на начало списка, т.к изменяется
{
	// узаление происходит движение по списку с первого элемента до последнего
	Node* ptr;                        // указатель на очередной узел списка
	ptr = NULL;                       // инициализировали его, чтобы не был диким
	while (*head != NULL)             // пока не вышли за пределы списка
	{  
		ptr = (*head)->next;          // запоминаем следующий за первым узел списка
		delete *head;                 // удалили первый узел
		*head = ptr;                  // переместили начало на запомненный узел
		// теперь удаляем его
	}//while (*head != NULL)
	// после удаления списка больше нет - указатель на начало нулевой
	// выводим список после удаления для проверки
	cout << "\n\x1b[32mПроверка на удаление списка:\x1b[30m \n\n";
	List_output(*head);
	// для проверки выводим значение указателя на начало списка
	cout << "\nЗначение указателя начала списка: \n";
	cout << *head;
	cout<<" --> \x1b[36mсписок удалился полностью\x1b[30m \n\n";
	return;                           // удалили список - вернулись в caller
}// Deleting_a_List()


/*-----------------------------------------------------------------------------*/
/* поиск в списке элемента с заданным значением */
/*----------------------------------------------*/
void List_search(Node* head)          // указатель на начало списка, чтобы двигаться от него до конца списка
{ 
	Node* ptr;                        // указатель на очередной узел списка
	ptr = head;                       // начием двигаться от начала списка по порядку
	int search_elem;                  // элемент поиска
	int n = 1;                        // для вывода его номера в списке
	bool flag = true;                 // флаг того, нашли или не нашли элемент
	cout << "Введите элемент поиска: ";
	cin >> search_elem;               // ввод пользователем элемента поика
	cout << "Вы ввели: " << search_elem << endl;
	if (!cin.good())                  // если в качестве элемента введено не число
	{// выход по ошибке
		cout << "Ошибка ввода числа поиска \n";
		cin.clear();                  // изменили идентификатор состояния 
		return;                       // вернулись в caller    
	}// if (!cin.good())

	while (ptr!= NULL)                // отслеживаем выход за пределы списка
	{
		// если данные очередного узла совпадают с теми, которые ищем
		if (ptr->Data == search_elem)
		{
			// нашли - поменяли флаг того, что не нашли
			flag = false;
			// вывели сам элемент и его номер
			cout << "\nНашли элемент: "<< ptr->Data;
			cout << "\nЕго номер в списке: " << n;
			// для убеждения того, что действительно нашли элемент, выводим следующий за ним узел, если таковой существует
			if (ptr->next != NULL)
			{
				cout<<"\nСледующий за ним элемент списка: " << ptr->next->Data;
			}
			// если следующего узла не существует, уведомляем об этом пользователя
			else
			{
				cout << "\nСледующего элемента за элементом поиска нет\n";
			}// if (ptr->next != NULL)
			cout << endl;
		}//if (ptr->Data == search_elem)
		// так как могут быть повторы по условию, то продолжаем сдвигаться каждый раз до конца, даже если уже нашли элемент
		ptr = ptr->next;
		// увеличиваем индекс элемента поиска
		n = n + 1;
	}// while (ptr!= NULL) 
	// выводим подкрашенный узел с искомым элементом
	cout << "\n\nЭлемент в списке: \n";
	List_output_search(head, search_elem);
	// если так и не нашли элемент - флаг не поменялся. Выводим сообщение об ошибке поиска
	if (flag)
	{
		cout << "\n\x1b[31mЭлемента с заданным значением в списке нет\x1b[30m\n\n";
	}// if (flag)
	return;                           // нашли - вернулись в caller
}// List_search()


/*-----------------------------------------------------------------------------*/
/* вывод подкрашенной ячейки в списке после поиска */
/*-------------------------------------------------*/
void List_output_search(Node* head     // указатель на начало списка, чтобы двигаться от него до конца списка
	                  , int uzel)      // значение, которое будем подкрашивать в списке
{
	setlocale(0, "C");                 // отключаем русский язык
	Node* ptr;                         // указатель на очередной узел списка                 
	ptr = head;                        // начием двигаться от начала списка по порядку
	int n = 1;                         // для вывода нумерации элементов
	// пока не вышли за пределы списка
	while (ptr != NULL)
	{
		// если дошли до узла, в котором содержится искомый элемент
		if (ptr->Data == uzel)
		{
			// выделяем ячейку красным цветом
			cout << "\x1b[31m";
			// выводим шапку
			cout << char(218) << setw(7) << setfill((char)196) << (char)194 << setw(7) << setfill((char)196) << char(191);
			// выводим левую границу, само значение и разделитель
			cout << "\n" << char(179) << setw(4) << setfill(' ') << ptr->Data  << setw(3) << setfill(' ') << char(179);
			// выводим указатель, правую границу и номер элемента
			cout << setw(5) << setfill(' ') << "NEXT" << setw(2) << char(179) << setw(9) << setfill(' ') << "n = " << n << setw(12) << setfill(' ') << "NEXT = " << ptr->next << endl;
			// выводим нижнюю границу таблицы
			cout << char(192) << setw(7) << setfill((char)196) << (char)193 << setw(7) << setfill((char)196) << char(217) << endl;
			cout <<"\x1b[30m";
			cout << endl;
		}// if (ptr->Data == uzel)
		n = n + 1;                      // увеличили счётчик элементов
		ptr = ptr->next;                // перешли к следующему узлу списка
	}//	while (ptr != NULL)	 
	setlocale(LC_ALL, "Rus");           // подключаем русский язык
	return;                             // вывели - вернулись в caller
}// List_output_search()


/*-----------------------------------------------------------------------------*/
/* добавление нового элемента в начало списка */
/*--------------------------------------------*/
void Adding_to_the_top(Node** head)     // указатель на указатель на начало списка, т.к изменяется
{
	int input_elem;                     // элемент, который будем добавлять
	Node* ptr;                          // указатель на очередной узел списка 
	ptr = new Node;                     // создали новый узел
	cout << "\nКакой элемент Вы будете добавлять в начало списка: ";
	cin >> input_elem;                  // ввод пользователем значения
	cout << "Вы ввели: " << input_elem << endl;
	if (!cin.good())                    // если элемент добавления - не число
	{// выход по ошибке
		cout << "Ошибка ввода числа добавления \n";
		cin.clear();
		return;                         // вернулись в caller    
	}//if (!cin.good()) 
	ptr->Data = input_elem;             // положили в новый не подсоединённый узел значение, которое хотим добавить
	// если список пуст
	if (*head == NULL) 
	{ 
		*head = ptr;                    // новый элемент станет новой головой списка
		(*head)->next = NULL;           // обнулили соответствующий указатель на слудующий элемент, т.к список состоит из одного элемента
	}
	// если уже есть список
	else
	{
		ptr->next = *head;              // ставим новый элемент в начало, присваивая ему указатель на старую голову списка
		*head = ptr;                    // голова сдвинулась после добавления в начало
	}// (*head == NULL) 
	// вывели список после добавления в начало элемента
	cout << "\n\x1b[33mСписок после добавления элемента в начало:\x1b[30m \n";
	List_output(*head);
	return;                              // добавили - вернулись в caller
}// Adding_to_the_top()


/*-----------------------------------------------------------------------------*/
/* удаление элемента из конца списка */
/*-----------------------------------*/
void Deletion_at_the_end(Node** head)    // указатель на указатель на начало списка, т.к может измениться
{
	Node* ptr;                           // указатель на очередной узел списка 
	Node* previous;                      // указатель на его предшественника
	previous = NULL;                     // положили значение, чтобы не был диким     
	ptr = *head;                         // проходим по списку с начала до конца
	// если список пуст
	if (ptr == NULL)
	{
		// удалять нечего - оповещаем об этом
		cout << "\n\x1b[31mУдалять нечего - список пустой\x1b[30m\n\n";
		return;                           // удалили - вернулись в caller
	}// if (ptr == NULL)
	// если список из одного элемента. Нет предыдущего элемента списка
	else if (ptr->next == NULL)
	{
		// удалили узел-голову
		delete ptr;
		// обнулили соответствующий указатель
		*head = NULL;
		// вывели для проверки сам список после удаления и указатель на его голову
		cout << "\n\x1b[33mСписок после удаления элемента в конце:\x1b[30m \n\n";
		List_output(*head);
		cout << endl;
		cout << "Начало списка: " << *head << endl;
		return;                           // удалили - вернулись в caller
	}// else if (ptr->next == NULL)
	// остались списки с 2+ узлами. Родитель есть
	// идём, пока не дошли до последнего узла списка
	while (ptr->next != NULL)
	{
		// previous всегда будет перед ptr
		// запомнили ptr
		previous = ptr;
		// сдвинули ptr
		ptr = ptr->next;
	}// while (ptr->next != NULL)
	delete ptr;                           // удалили последний узел
	previous->next = NULL;                // предудущему от него элементу поставили конец списка - NULL
	//выводим список и его начала после удаления для проверки
	cout << "\n\x1b[33mСписок после удаления элемента в конце:\x1b[30m \n\n";
	List_output(*head);
	cout << endl;
	cout << "Начало списка: " << *head << endl;
	return;                               // удалили - вернулись в caller
}// Deletion_at_the_end()


/*-----------------------------------------------------------------------------*/
/* удаление элемента из начала списка */
/*------------------------------------*/
void Deletion_at_the_beginning(Node** head)   // указатель на указатель на начало списка, т.к изменяется
{
	Node* ptr;                                // указатель на очередной узел списка 
	ptr = *head;                              // проходим по списку с начала до конца
	// если список пуст *head == NULL
	if (ptr == NULL)
	{
		// удалять нечего - оповещаем об этом
		cout << "\n\x1b[31mУдалять нечего - список пустой\x1b[30m\n\n";
		return;                               // удалили - вернулись в caller
	}// if (ptr == NULL)
	ptr = (*head)->next;                      // сдвинулись ко второму узлу списка
	delete* head;                             // удалили первый узел списка
	*head = ptr;                              // поставили начало на второй узел списка. Он стал первым
	// вывели список после удаления первого элемента и адрус нового первого узла
	cout << "\n\x1b[33mСписок после удаления элемента в начале:\x1b[30m \n\n";
	List_output(*head);
	cout << endl;
	cout << "Начало списка: " << *head << endl;
	return;                                   // удалили - вернулись в caller
}// Deletion_at_the_beginning()


/*-----------------------------------------------------------------------------*/
/* удаление элемента с заданным номером в списке */
/*-----------------------------------------------*/
void Deletion_by_number(Node** head)      // указатель на указатель на начало списка, т.к может измениться
{
	int uzel_ud;                          // номер удаляемого узла
	Node* ptr;                            // указатель на очередной узел списка
	Node* parent;                         // указатель на его предшественника
	int n = 1;                            // для отслеживания номера удаляемого элемента
	ptr = * head;                         // проходим по списку с начала до конца
	parent = NULL;                        // положили значение, чтобы не был диким   
	cout << "\nЭлемент под каким номером в списке Вы будете удалять? Введите число:";
	cin >> uzel_ud;                       // ввод номера удаляемого узла списка
	cout << "\nВы ввели: " << uzel_ud;
	if (!cin.good())                      // если введённый номер - не число
	{// выход по ошибке
		cout << "\nОшибка ввода номера индекса удаления \n";
		cin.clear();
		return;                           // вернулись в caller    
	}//if (!cin.good())
	// если список пуст
	if (ptr == NULL)
	{
		// удалять нечего - оповестили об ошибке удаления
		cout << "\n\x1b[31mВведённый номер находится за пределами номеров списка!!!\x1b[30m\n\n";
		return;                           // удалили - вернулись в caller 
	}// if (ptr == NULL)
	//если нужно удалить первый узел (берется случай, когда в списке 1 элемент)
	else if (uzel_ud == 1)
	{
		// вызываем функцию удаления первого узла
		Deletion_at_the_beginning(head);
		return;                            // удалили - вернулись в caller 
	}//else if (uzel_ud == 1)
	// отслеживаем выход за пределы списка
	// остались списки 2+ элементов
	while (ptr != NULL)
	{
		if (n == uzel_ud)                  // если номер, введённый пользователем существует в списке
		{
			parent->next = ptr->next;      // присвоили родителю удаляемого элемента следующий элемент за удаляемым
			delete ptr;                    // удалили сам элемент
			// вывели список после удаления и указатель на начало списка для проверки
			cout << "\n\x1b[33mСписок после удаления элемента c номером " << n << ":\x1b[30m \n\n";
			List_output(*head);
			cout << endl;
			cout << "Начало списка: " << *head << endl;
			return;                        // удалили - вернулись в caller 
		}// if (n == uzel_ud)
		// если еще не дошли до uzel_ud
		n = n + 1;                         // перешли к следующему элементу списка
		parent = ptr;                      // запоминаем родителя
		ptr = ptr->next;                   // ставим указатель на следующий узел
	}// while (ptr != NULL)
	// если так и не докрутили счётчик до введённого индекса, то ошибка ввода индекса: он за пределами списка
	if(n != uzel_ud)
	{
		// вывели сообщение об ошибке
		cout << "\n\x1b[31mВведённый номер находится за пределами номеров списка!!!\x1b[30m\n\n";
		return;                            // удалили - вернулись в caller
	}// if(n != uzel_ud)
	return;                                // удалили - вернулись в caller
}// Deletion_by_number()


/*-----------------------------------------------------------*/
/* выбор функции из массива                 */
/*------------------------------------------*/
void(*MENU(int& vubor))                    // функция, выбранная пользователем
(Node**)                                   // спецификация параметров функции
{
	// массив указателей на функции, соответствующие данной спецификации. На месте тех, кторые не соответствуют - нули. Раберёмся с ними позже
	void (*functions_lists[])(Node**) = {NULL, NULL, Deleting_a_List, NULL, Adding_to_the_top, Deletion_at_the_end, Deletion_at_the_beginning, Deletion_by_number};
	cout << "\nВыберете функцию: 1 - 10, где 9 - повторение программы с другими числами в массиве, а 10 - выход \n";
	// ввод пользователем номера операции над списком
	cout << "Вы ввели: ";
	cin >> vubor;                           // ввод выбора операции со списком пользователем
	if ((vubor > 0) && (vubor < 9))         // если попали в диапазон номеров из таблицы
	{
		// вернули соответствующий указатель из массива
		return (functions_lists[vubor - 1]);
	}
	else // пользователь ввёл число вне диапазона функций из таблицы или ввёл EXIT или Repeat
	{
		return NULL;                        // нулевой указатель - сбой работы, вернули в caller
	}// if((vubor > 0) && (vubor < 9))
}// MENU()


/*-----------------------------------------------------------*/
/* работа с выбранной операцией над списком */
/*------------------------------------------*/
void pechat_mass_lists(int* pznachenue         // указатель на первый элемент динамического массива-вектора
	                 , Node** head             // указатель на указатель на начало списка, т.к он передаётся далее в другие функции
	                 , int number)             // количество элементов в массиве-векторе
{
	int vubor = 0;                             // номер функции, выбранной пользователем         
	void(*choiсe)(Node**);                     // указатель на функцию, выбранную пользователем
	// массив имён операций над списком для вывода
	string name[8] = { "L i s t   c r e a t i o n", "L i s t   o u t p u t", "D e l e t i n g   a   L i s t", "L i s t   s e a r c h", "A d d i n g   t o   t h e   t o p", "D e l e t i o n   a t   t h e   e n d", "D e l e t i o n   a t   t h e   b e g i n n i n g", "D e l e t i o n   b y   n u m b e r"};
	cout << "\t\t\t\t\x1b[35mОПРЕДЕЛИМСЯ С КОЛИЧЕСТВОМ ЭЛЕМЕНТОВ В ИЗНАЧАЛЬНОМ СПИСКЕ\x1b[30m\n\n";
	sozdanie(&pznachenue, number);             // создали динамические массивы с регулируемым числом элементов
	zapolnenie(pznachenue, number);            // заполнили динамический массив
	system("cls");                             // очистили экран - перешли к основной программе
	while (1)                                  // бесконечный цикл выбора до момента пока пользователь не выберет Exit или не ошибётся.
	{
		cout << "\t\t\t\t\t \x1b[34mР А Б О Т А   С О   С П И С К А М И\x1b[30m\n\n";
		cout << "Количество элементов в массиве : " << number << endl;  // эхо-печать
		pechatusloviy();                        // вывод функции печати условий
		cout << "\x1b[31mЗАМЕЧАНИЕ:\x1b[30m при удалении или формировании нового списка создавайте его заново!!!\n";
		cout << "\x1b[31mЗАМЕЧАНИЕ:\x1b[30m После удаления списка полностью, чтобы продолжать добавьте какие-то элементы или закончите программу!\n\n";
		choiсe = MENU(vubor);                   // присваиваем указателю функцию из массива, выбранную пользователем
		pechat_tabl(pznachenue, number);        // распечатали заполненный массив в скобках
		cout << "\n\n\t\t\t\t\t\t \x1b[34m ИСХОДНЫЙ СПИСОК: \x1b[30m \n\n";
		List_output(*head);                     // выводим список до каких - либо действий с ним
		if (choiсe == NULL)                     // если вышли за рамки диапазона допустимого Exit или Repeat или наткнулись ну функцию, спецификации которой не позволяли поместить её в массив
		{
			// разграничиваем эти случаи
			switch (vubor)
			{
				case 1:                         // пользователь выбрал создать список
				{
					// пишем об этом на экране
					cout << "\n\t\t\t\t\t\x1b[35mО П Е Р А Ц И Я   " << name[vubor - 1] << "\x1b[30m" << endl;      // выводим название алгоритма из массива
					// вызываем функцию создания списка
					List_creation(head, pznachenue, number);
					system("pause"); 
					system("cls");              // чистим экран после очередной операции
					// начинаем while с начала
					continue;
				}// case 1
				case 2:                         // пользователь выбрал вывести на экран список
				{
					// пишем об этом на экране
					cout << "\n\t\t\t\t\t\x1b[35mО П Е Р А Ц И Я   " << name[vubor - 1] << "\x1b[30m" << endl;      // выводим название алгоритма из массива
					// вызываем функцию печати списка
					List_output(*head);
					system("pause");
					system("cls");              // чистим экран после очередной операции
					// начинаем while с начала
					continue;
				}// case 2
				case 4:                         // пользователь выбрал функцию поиска элемента в списке
				{
					// пишем об этом на экране
					cout << "\n\t\t\t\t\x1b[35mО П Е Р А Ц И Я   " << name[vubor - 1] << "\x1b[30m" << endl;      // выводим название алгоритма из массива
					// вызываем функцию поиска элемента
					List_search(*head);
					system("pause");
					system("cls");              // чистим экран после очередной операции
					// начинаем while с начала
					continue;
				}// case 4
				case 9:                         // пользователь выбрал Repeat
				{
					udalenie(pznachenue);       // удаляем ранее созданные массивы
					Deleting_a_List(head);      // удаляем ранее созданный список
					cout << "\t\t\t\t\x1b[31mНачинаем построение списка с другими числами!!!\x1b[30m\n\n";
					system("pause");
					system("cls");              // чистим экран
					cout << "\t\t\t\t\x1b[35mОПРЕДЕЛИМСЯ С КОЛИЧЕСТВОМ ЭЛЕМЕНТОВ В МАССИВЕ И С ВИДОМ СЛУЧАЯ\x1b[30m\n\n";
					sozdanie(&pznachenue, number);   // создали динамический массив с регулируемым числом элементов заново
					zapolnenie(pznachenue, number);  // заполнили динамический массив заново
					system("cls");                   // перешли опять к основной программе
					continue;                        // запускаем цикл заново  
				}// case 8
				default:                             // пользователь выбрал Exit, или ошибся
				// завершаем программу по ошибке
					udalenie(pznachenue);            // удалили ранее созданный массив 
					Deleting_a_List(head);
					cout << "\n\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
					system("pause");
					exit(1);                         // закончили программу из функции                                          
			}// switch (vubor)
		}//	 if (choiсe == NULL) 
		// если пользователь выбрал функцию из массива в MENU
		cout << "\n\t\t\t\t\t\x1b[35mО П Е Р А Ц И Я   " << name[vubor - 1] << "\x1b[30m" << endl;   // выводим название алгоритма из массива
		choiсe(head);                                                                                // вызвали функцию, выбранную из массива через указатель
		system("pause");
		system("cls");                               // чистим экран после очередной операции
	}
	udalenie(pznachenue);                            // отработали - сделали всё, что хочет пользователь. Удалили ненужный массив
	Deleting_a_List(head);                           // отработали - удалили ранее созданный список
	return;                                          // возвращаем значение, соответствующее типу в caller
}// pechat_mass_lists()